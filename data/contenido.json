[{"nombre":"- I/O Lectura (objetos, tipos complejos)","main":"Para leer objetos en un archivo en Java utilizando fileInputStream, BufferedInputStream, y ObjectInputStream, puedes seguir estos pasos:\n\nCrear un objeto FileInputStream para especificar el archivo en el que deseas leer.\nEnvolver en BufferedOutputStream para mejorar la eficiencia de escritura.\nEnvolver en ObjectOutputStream para leer objetos","characters":"import java.io.BufferedInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\n\npublic class LeerObjetoString {\n    public static void main(String[] args) {\n        // Nombre del archivo que se va a leer\n        String nombreArchivo = \"objetoString.dat\";\n\n        try (\n            // Crear FileInputStream para el archivo\n            FileInputStream fileInputStream = new FileInputStream(nombreArchivo);\n\n            // Envolver en BufferedInputStream para mejorar la eficiencia de lectura\n            BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);\n\n            // Envolver en ObjectInputStream para leer objetos\n            ObjectInputStream flujoEntrada = new ObjectInputStream(bufferedInputStream)\n        ) {\n            // Leer el objeto String desde el archivo\n            String cadenaLeida = (String) flujoEntrada.readObject();\n\n            // Imprimir el objeto String leído\n            System.out.println(\"Objeto String leído del archivo: \" + cadenaLeida);\n        } catch (IOException | ClassNotFoundException e) {\n            System.out.println(\"Excepción: \" + e);\n        }\n    }\n}\n"},{"nombre":"- I/O Lectura (datos primitivos)","main":"Para leer datos primitivos en un archivo en Java utilizando DataOutputStream, BufferedOutputStream, y FileOutputStream, puedes seguir estos pasos:\n\nCrear un objeto FileInputStream para especificar el archivo en el que deseas leer.\nEnvolver en BufferedInputStream para mejorar la eficiencia de lectura.\nEnvolver en DataInputStream para leer datos primitivos.","characters":"import java.io.BufferedInputStream;\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class LeerDatosPrimitivos {\n    public static void main(String[] args) {\n        // Nombre del archivo que se va a leer\n        String nombreArchivo = \"datosPrimitivos.dat\";\n\n        try (\n            // Crear FileInputStream para el archivo\n            FileInputStream fileInputStream = new FileInputStream(nombreArchivo);\n\n            // Envolver en BufferedInputStream para mejorar la eficiencia de lectura\n            BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);\n\n            // Envolver en DataInputStream para leer datos primitivos\n            DataInputStream flujoEntrada = new DataInputStream(bufferedInputStream)\n        ) {\n            // Leer datos primitivos\n            int enteroLeido = flujoEntrada.readInt();\n            double doubleLeido = flujoEntrada.readDouble();\n            boolean booleanLeido = flujoEntrada.readBoolean();\n\n            // Imprimir los datos leídos\n            System.out.println(\"Entero leído: \" + enteroLeido);\n            System.out.println(\"Double leído: \" + doubleLeido);\n            System.out.println(\"Boolean leído: \" + booleanLeido);\n        } catch (IOException e) {\n            System.out.println(\"IOException: \" + e);\n        }\n    }\n}\n"},{"nombre":"- I/O Escritura (objetos, tipos complejos)","main":"Para escribir objetos en un archivo en Java utilizando ObjectOutputStream, BufferedOutputStream, y FileOutputStream, puedes seguir estos pasos:\n\nCrear un objeto FileOutputStream para especificar el archivo en el que deseas escribir.\nEnvolver en BufferedOutputStream para mejorar la eficiencia de escritura.\nEnvolver en ObjectOutputStream para escribir objetos","characters":"import java.io.BufferedOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\n\npublic class EscribirObjetoString {\n    public static void main(String[] args) {\n        // Nombre del archivo en el que se escribirá el objeto String\n        String nombreArchivo = \"objetoString.dat\";\n\n        try (\n            // Crear FileOutputStream para el archivo\n            FileOutputStream fileOutputStream = new FileOutputStream(nombreArchivo);\n\n            // Envolver en BufferedOutputStream para mejorar la eficiencia de escritura\n            BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);\n\n            // Envolver en ObjectOutputStream (antes ObjectOutput) para escribir objetos\n            ObjectOutputStream flujoSalida = new ObjectOutputStream(bufferedOutputStream)\n        ) {\n            // String a escribir en el archivo\n            String cadenaAEscribir = \"Hola, esto es un objeto String.\";\n\n            // Escribir el objeto String en el archivo\n            flujoSalida.writeObject(cadenaAEscribir);\n\n            System.out.println(\"Objeto String escrito en el archivo: \" + nombreArchivo);\n        } catch (IOException e) {\n            System.out.println(\"IOException: \" + e);\n        }\n    }\n}\n"},{"nombre":"- I/O Escritura (datos primitivos)","main":"Para escribir datos primitivos en un archivo en Java utilizando DataOutputStream, BufferedOutputStream, y FileOutputStream, puedes seguir estos pasos:\n\nCrear un objeto FileOutputStream para especificar el archivo en el que deseas escribir.\nEnvolver el FileOutputStream en un BufferedOutputStream para mejorar la eficiencia de escritura.\nEnvolver el BufferedOutputStream en un DataOutputStream para poder escribir datos primitivos.","characters":"import java.io.BufferedOutputStream;\nimport java.io.DataOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class EscribirDatosPrimitivos {\n    public static void main(String[] args) {\n        // Nombre del archivo en el que se escribirán los datos\n        String nombreArchivo = \"datosPrimitivos.dat\";\n\n        try (\n            // Crear FileOutputStream para el archivo\n            FileOutputStream fileOutputStream = new FileOutputStream(nombreArchivo);\n            \n            // Envolver en BufferedOutputStream para mejorar la eficiencia de escritura\n            BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);\n            \n            // Envolver en DataOutputStream para escribir datos primitivos\n            DataOutputStream flujoSalida = new DataOutputStream(bufferedOutputStream)\n        ) {\n            // Escribir datos primitivos\n            flujoSalida.writeInt(42);\n            flujoSalida.writeDouble(3.14);\n            flujoSalida.writeBoolean(true);\n\n            System.out.println(\"Datos primitivos escritos en el archivo: \" + nombreArchivo);\n        } catch (IOException e) {\n            System.out.println(\"IOException: \" + e;\n        }\n    }\n}\n"},{"nombre":"- Genericidad (T)","main":"La genericidad es una característica que permite a los desarrolladores escribir código que puede trabajar con tipos (T) específicos sin conocerlos de antemano.\n\nSe implementa mediante la introducción de parámetros de tipo en clases, interfaces y métodos. Los parámetros de tipo son especificados entre ángulos (< >) y se utilizan para indicar qué tipo de objetos puede manejar o producir una clase, interfaz o método.\n\nLa elección de \"T\" es una abreviatura de \"Type\" (tipo en inglés), y es comúnmente utilizada por la comunidad de programadores como una convención para indicar un parámetro de tipo genérico. No tiene un significado especial para el compilador","characters":"class Caja<T> { // Clase genérica con un parámetro de tipo T\n    private T contenido;\n\n    public Caja(T contenido) { //Constructor\n        this.contenido = contenido;\n    }\n\n    public T obtenerContenido() { // Método para obtener el contenido\n        return contenido;\n    }\n}\n\npublic class Main { // Ejemplo de uso\n    public static void main(String[] args) {\n        // Crear una caja de tipo Integer\n        Caja<Integer> cajaEntero = new Caja<>(42);\n        // Crear una caja de tipo String\n        Caja<String> cajaTexto = new Caja<>(\"Hola, mundo\");\n\n        System.out.println(\"Contenido de la caja de enteros: \" + cajaEntero.obtenerContenido());\n        System.out.println(\"Contenido de la caja de texto: \" + cajaTexto.obtenerContenido());\n    }\n}\n"},{"nombre":"long (tipo primitivo)","main":"Un tipo primitivo (o tipo de dato primitivo) se refiere a un tipo de dato básico que no está compuesto por otras estructuras de datos. Estos tipos de datos primitivos son los elementos fundamentales con los que se construyen los programas y se utilizan para representar valores simples\n\nEn Java, long es un tipo de dato primitivo que se utiliza para representar números enteros de mayor tamaño en comparación con int, ocupa 64 bits o 8 bytes en la memoria y el rango de valores que puede almacenar un long va desde -2^63 hasta 2^63 - 1.\nIMPORTANTE: Al asignar un valor a una variable long, es necesario agregar el sufijo \"L\" al final del número. Si no se proporciona el sufijo, el compilador podría generar un error si el valor supera el rango de un int.","characters":"long a = 1234567890L;\nlong b = 9876543210L;\nlong suma = a + b;      // suma = 11111111100\nlong resta = a - b;     // resta = -8641975310\nlong multiplicacion = a * b;  // multiplicacion = 12193263111263526900\nlong division = b / a;  // division = 8\n"},{"nombre":"int (tipo primitivo)","main":"Un tipo primitivo (o tipo de dato primitivo) se refiere a un tipo de dato básico que no está compuesto por otras estructuras de datos. Estos tipos de datos primitivos son los elementos fundamentales con los que se construyen los programas y se utilizan para representar valores simples\n\nEn Java, int es un tipo de dato primitivo que se utiliza para representar números enteros y cupa 32 bits o 4 bytes en la memoria. El rango de valores que puede almacenar un int va desde -2^31 hasta 2^31 - 1. ","characters":"int a = 10;\nint b = 20;\nint suma = a + b;      // suma = 30\nint resta = a - b;     // resta = -10\nint multiplicacion = a * b;  // multiplicacion = 200\nint division = b / a;  // division = 2\n"},{"nombre":"float (tipo primitivo)","main":"Un tipo primitivo (o tipo de dato primitivo) se refiere a un tipo de dato básico que no está compuesto por otras estructuras de datos. Estos tipos de datos primitivos son los elementos fundamentales con los que se construyen los programas y se utilizan para representar valores simples\n\nfloat se utiliza para representar números decimales y ocupa 32 bits o 4 bytes en la memoria.\n\nPrecisión:  la precisión de un float es limitada en comparación con double, puedes representar números con hasta 7 dígitos precisos, a partir de ahi seran aproximados ( 12345.6789, todos los dígitos 1234567 serían considerados significativos, y el dígito 8 podría ser menos preciso).\n\nEs importante añadir la \"f\" al final del número para indicar que es de tipo float. Si no se proporciona, el compilador podría tratar el número como double.","characters":"float a = 3.5f;\nfloat b = 2.0f;\nfloat suma = a + b;      // suma = 5.5\nfloat resta = a - b;     // resta = 1.5\nfloat multiplicacion = a * b;  // multiplicacion = 7.0\nfloat division = a / b;  // division = 1.75\n\n//TAMBIEN PERMITE NOTACION CIENTIFICA\nfloat cientifico = 2.5e-3f;  // 0.0025\n"},{"nombre":"double (tipo primitivo)","main":"Un tipo primitivo (o tipo de dato primitivo) se refiere a un tipo de dato básico que no está compuesto por otras estructuras de datos. Estos tipos de datos primitivos son los elementos fundamentales con los que se construyen los programas y se utilizan para representar valores simples\n\ndouble en Java se utiliza para representar números de punto flotante de doble precisión, ocupa 64 bits o 8 bytes en la memoria y puede representar números con aproximadamente 15 dígitos significativos. ","characters":"double a = 3.5;\ndouble b = 2.0;\ndouble suma = a + b;      // suma = 5.5\ndouble resta = a - b;     // resta = 1.5\ndouble multiplicacion = a * b;  // multiplicacion = 7.0\ndouble division = a / b;  // division = 1.75\n"},{"nombre":"arrayList (tipo complejo)","main":"Un ArrayList es una implementación de la interfaz List, que es parte del marco de trabajo de Collections en Java. Representa una lista dinámica de elementos, lo que significa que su tamaño puede cambiar dinámicamente durante la ejecución del programa.\n\nLas principales características de un ArrayList son:\n1) Tamaño Dinámico: A diferencia de los arrays tradicionales en Java, los ArrayLists pueden crecer o reducir su tamaño dinámicamente según la cantidad de elementos que contienen.\n2) Acceso Rápido por Índice: Al igual que los arrays, puedes acceder a los elementos de un ArrayList mediante su índice.\n3) Implementa la Interfaz List: Al ser parte de la interfaz List, un ArrayList hereda todas las funcionalidades de una lista, como agregar elementos, eliminar elementos, buscar elementos, etc.\n4) Permite Elementos Duplicados y Nulos: Puedes almacenar elementos duplicados y valores nulos en un ArrayList.\n5) Mejora Iteración: Puedes iterar fácilmente a través de los elementos de un ArrayList utilizando bucles for o bucles foreach (bucle for-each).","characters":"import java.util.ArrayList;\n\nArrayList<Integer> listaDeEnteros = new ArrayList<>();\nlistaDeEnteros.add(10);\nlistaDeEnteros.add(20);\nlistaDeEnteros.add(30);\n\n//BORRAR ELEMENTO EN POSICION 1\nlista.remove(1);\nlista.remove(Integer.valueOf(20));\n\n//RECORRER ARRAYLIST CON BUCLE FOR\nfor (int i = 0; i < listaDeEnteros.size(); i++) {\n    System.out.println(listaDeEnteros.get(i););\n}\n\n//RECORRER ARRAYLIST CON BUCLE FOREACH\nfor (int numero : listaDeEnteros) {\n    System.out.println(numero);\n}"},{"nombre":"While (bucle)","main":"El bucle while en Java se utiliza para ejecutar un bloque de código repetidamente mientras una condición específica sea verdadera.\n\nLa condición es evaluada antes de entrar en el bucle. Si la condición es verdadera, el bloque de código dentro del bucle se ejecutará. Después de cada ejecución del bloque, la condición se vuelve a evaluar. Si la condición sigue siendo verdadera, el bucle se repetirá. Si la condición es falsa desde el principio, el bloque dentro del bucle no se ejecutará \n\nEs fundamental asegurarse de que la condición del bucle eventualmente se vuelva falsa para evitar un bucle infinito","characters":"public class EjemploWhile {\n    public static void main(String[] args) {\n        int contador = 1;\n\n        while (contador <= 5) {\n            System.out.println(\"Número: \" + contador);\n            contador++;\n        }\n    }\n}\n"},{"nombre":"- Herencia (clase abstracta)","main":"Una clase abstracta es una clase que NO PUEDE CREAR OBJETOS por sí misma y debe contener al menos un metodo abstracto, también puede contener métodos implementados. Además, puede tener propiedades (campos o atributos) que son comunes a todas las clases derivadas.\n\nUn método abstracto es un método que se declara en la clase abstracta pero no tiene implementación. Su implementación real debe proporcionarse en las clases hijas, esto asegura que las subclases proporcionen una implementación específica para esos métodos proporcionando una interfaz común a través de la cual las clases hijas pueden compartir comportamientos similares.","characters":"abstract class CuentaBancaria { // Clase abstracta CuentaBancaria\n    private String numeroCuenta;\n    protected double saldo;\n\n    // Constructor\n    public CuentaBancaria(String numeroCuenta, double saldoInicial) {\n        this.numeroCuenta = numeroCuenta;\n        this.saldo = saldoInicial;\n    }\n\n    public String getNumeroCuenta() {\n        return numeroCuenta;\n    }\n\n    public double getSaldo() {\n        return saldo;\n    }\n\n    public void ingresar(double cantidad) {\n        saldo += cantidad;\n    }\n\n    public void retirar(double cantidad) {\n        if (cantidad <= saldo) {\n            saldo -= cantidad;\n        } else {\n            System.out.println(\"Saldo insuficiente.\");\n        }\n    }\n\n    // Método abstracto para calcular intereses\n    public abstract void calculaIntereses();\n}\n\nclass CuentaCorriente extends CuentaBancaria { // Clase CuentaCorriente que hereda de CuentaBancaria\n    // Constructor\n    public CuentaCorriente(String numeroCuenta, double saldoInicial) {\n        super(numeroCuenta, saldoInicial);\n    }\n\n    @Override\n    public void calculaIntereses() {     // Implementación específica del método abstracto\n        // Lógica específica para calcular intereses en una cuenta corriente\n        System.out.println(\"Calculando intereses para cuenta corriente.\");\n    }\n}\n\nclass CuentaAhorro extends CuentaBancaria { // Clase CuentaAhorro que hereda de CuentaBancaria\n    // Constructor\n    public CuentaAhorro(String numeroCuenta, double saldoInicial) {\n        super(numeroCuenta, saldoInicial);\n    }\n\n    @Override\n    public void calculaIntereses() {     // Implementación específica del método abstracto\n        // Lógica específica para calcular intereses en una cuenta de ahorro\n        System.out.println(\"Calculando intereses para cuenta de ahorro.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) { // Ejemplo de uso\n        CuentaCorriente cuentaCorriente = new CuentaCorriente(\"123456\", 1000.0);\n        CuentaAhorro cuentaAhorro = new CuentaAhorro(\"789012\", 2000.0);\n\n        // Operaciones comunes\n        cuentaCorriente.ingresar(500.0);\n        cuentaCorriente.retirar(200.0);\n\n        cuentaAhorro.ingresar(1000.0);\n        cuentaAhorro.retirar(300.0);\n\n        // Llamada a los métodos abstractos específicos\n        cuentaCorriente.calculaIntereses();\n        cuentaAhorro.calculaIntereses();\n    }\n}\n"},{"nombre":"- Herencia","main":"La herencia es un concepto fundamental en la programación orientada a objetos (POO) y permite la creación de clases nuevas basadas en clases existentes. En Java, la herencia se implementa a través de la relación de clases \"ES-UN\"\n\nUn buen ejemplo automovilistico seria: todoTerreno() ES-UN Vehiculo(), de forma que la clase todoTerreno() heredaria las funciones y propiedades de Vehiculo(), y por tanto el objeto instanciado de todoTerreno() heredaria estas mismas funciones y propiedades ademas de las funciones y propiedades de todoTerreno().\n\nTambien es posible desde la clase hija sobreescribir (@Override) ciertos metodos de la clase padre.","characters":"// Definición de la clase base Vehiculo\nclass Vehiculo {\n    // PROPIEDADES\n    String marca;\n    String modelo;\n    int año;\n\n    // Constructor\n    public Vehiculo(String marca, String modelo, int año) {\n        this.marca = marca;\n        this.modelo = modelo;\n        this.año = año;\n    }\n\n    // FUNCIONES\n    public void arrancar() {\n        System.out.println(\"El vehículo está arrancando.\");\n    }\n\n    public void detener() {\n        System.out.println(\"El vehículo se está deteniendo.\");\n    }\n}\n\n// Definición de la clase derivada todoTerreno() que hereda de Vehiculo()\nclass TodoTerreno extends Vehiculo {\n\n    public TodoTerreno(String marca, String modelo, int año) {\n        super(marca, modelo, año);\n    }\n\n    // Sobrescribe el método arrancar de la clase base\n    @Override\n    public void arrancar() {\n        System.out.println(\"El todo terreno está arrancando en modo todoterreno.\");\n    }\n\n    // Función adicional para vehículos todo terreno\n    public void activarModo4x4() {\n        System.out.println(\"Modo 4x4 activado para todo terreno.\");\n    }\n}\n\n// Ejemplo de uso\npublic class Main {\n    public static void main(String[] args) {\n        // Crear un objeto TodoTerreno\n        TodoTerreno patrol = new TodoTerreno(\"Nissan\", \"Patrol\", 2023);\n\n        // Acceder a las propiedades\n        System.out.println(\"Marca: \" + patrol.marca);\n        System.out.println(\"Modelo: \" + patrol.modelo);\n        System.out.println(\"Año: \" + patrol.año);\n\n        // Llamar a funciones heredadas de Vehiculo\n        patrol.arrancar();\n        patrol.detener();\n\n        // Llamar a la función específica de TodoTerreno\n        patrol.activarModo4x4();\n    }\n}\n"},{"nombre":"- Variables locales y globales","main":"Las VARIABLES LOCALES son declaradas dentro de un bloque de código específico, como un método, un bucle o una condición, la vida de una variable local comienza cuando se declara y termina cuando se sale del bloque en el que se declaró, y solo son accesibles dentro del bloque donde se declararon.\n\nLas VARIABLES GLOBALES (o variables de instancia) son declaradas a nivel de clase y fuera de cualquier método, la vida de una variable global está vinculada a la vida de la instancia de la clase a la que pertenece, y son accesibles para todos los métodos de la clase y están asociadas a una instancia particular de esa clase.\n","characters":"public class EjemploClase {\n    int variableGlobal; // Variable de instancia (global)\n    public EjemploClase(){ //Constructor\n        variableGlobal = 20; // Acceso dentro de cualquier método de la clase\n    }\n    public void metodo() {\n        int variableLocal = 10; // Variable local\n        System.out.println(variableLocal);\n        System.out.println(variableGlobal);\n    }\n}\n"},{"nombre":"Scanner (flujo de entrada)","main":"En Java, la clase java.util.Scanner se utiliza para leer la entrada del usuario desde el teclado","characters":"import java.util.Scanner;\n\nScanner flujoEntradaTeclado = new Scanner(System.in); //genera un objeto Scanner\n\nint numero = flujoEntradaTeclado.nextInt(); //Para leer un entero:\ndouble decimal = flujoEntradaTeclado.nextDouble(); //Para leer un número de punto flotante:\nString palabra = flujoEntradaTeclado.next(); //Para leer una cadena (hasta el próximo espacio en blanco):\nString linea = flujoEntradaTeclado.nextLine(); //Para leer una línea completa (hasta el final de la línea):\nflujoEntradaTeclado.close(); //Cierra el flujo\n\n\n\n"},{"nombre":"- Operadores","main":"OPERADORES ARITMETICOS:\nSuma (+): Suma dos operandos.\nResta (-): Resta el operando derecho del operando izquierdo.\nMultiplicación (*): Multiplica dos operandos.\nDivisión (/): Divide el operando izquierdo por el operando derecho.\nMódulo (%): Devuelve el resto de la división del operando izquierdo por el operando derecho.\n\nOPERADORES DE COMPARACION\nIgual a (==): Comprueba si dos valores son iguales.\nNo igual a (!=): Comprueba si dos valores no son iguales.\nMayor que (>): Comprueba si el valor izquierdo es mayor que el valor derecho.\nMenor que (<): Comprueba si el valor izquierdo es menor que el valor derecho.\nMayor o igual que (>=): Comprueba si el valor izquierdo es mayor o igual al valor derecho.\nMenor o igual que (<=): Comprueba si el valor izquierdo es menor o igual al valor derecho.\n\nOPERADORES UNARIOS\nIncremento (++): Incrementa el valor de la variable en 1.\nDecremento (--): Decrementa el valor de la variable en 1.\nPositivo (+): Devuelve el valor original del operando.\nNegativo (-): Cambia el signo del operando.\nNegación lógica (!): Invierte el valor booleano del operando.\n\nOPERADORES LOGICOS\nAND lógico (&&): Devuelve true si ambas expresiones booleanas son verdaderas, de lo contrario, devuelve false.\nOR lógico (||): Devuelve true si al menos una de las expresiones booleanas es verdadera, de lo contrario, devuelve false.\nNOT lógico (!): Invierte el valor booleano de la expresión. Si la expresión es true, devuelve false; si es false, devuelve true.\n\nOPERADORES DE ASIGNACION\nAsignación (=): Asigna el valor del lado derecho al operando del lado izquierdo.\nAdición y Asignación (+=): Incrementa el valor del operando izquierdo por el valor del operando derecho y luego asigna el resultado al operando izquierdo.\nSustracción y Asignación (-=): Decrementa el valor del operando izquierdo por el valor del operando derecho y luego asigna el resultado al operando izquierdo.\nMultiplicación y Asignación (*=): Multiplica el valor del operando izquierdo por el valor del operando derecho y luego asigna el resultado al operando izquierdo.\nDivisión y Asignación (/=): Divide el valor del operando izquierdo por el valor del operando derecho y luego asigna el resultado al operando izquierdo.\nMódulo y Asignación (%=): Calcula el módulo del valor del operando izquierdo por el valor del operando derecho y luego asigna el resultado al operando izquierdo.","characters":"OPERADORES ARITMETICOS\nSuma: \n   int resultado = 5 + 3;\nResta: \n   int resultado = 7 - 2;\nMultiplicación: \n   int resultado = 4 * 6;\nDivisión: \n   int resultado = 8 / 2;\nMódulo: \n   int resultado = 10 % 3;\n\nOPERADORES DE COMPARACION\nIgual a: \n   boolean esIgual = (5 == 5);\nNo igual a: \n   boolean noEsIgual = (4 != 7);\nMayor que: \n   boolean esMayor = (8 > 3);\nMenor que: \n   boolean esMenor = (2 < 6);\nMayor o igual que: \n   boolean esMayorIgual = (5 >= 5);\nMenor o igual que: \n   boolean esMenorIgual = (3 <= 4);\n\nOPERADORES UNARIOS\nIncremento: \n   int contador = 5;\n   contador++;\nDecremento: \n   int contador = 8; \n   contador--;\nPositivo: \n   int resultado = +7;\nNegativo: \n   int resultado = -10;\nNegación lógica: \n   boolean esVerdadero = true; \n   boolean noEsVerdadero = !esVerdadero;\n\nOPERADORES LOGICOS\nAND lógico (&&): \n   boolean esFalso = (true && false);\nOR lógico (||): \n   boolean esVerdadero = (true || false);\nNOT lógico (!): \n   boolean noEsVerdadero = !true;\n\nOPERADORES DE ASIGNACION\nint a = 5;\na += 3;  // Equivalente a: a = a + 3;\na -= 2;  // Equivalente a: a = a - 2;\na *= 4;  // Equivalente a: a = a * 4;\na /= 2;  // Equivalente a: a = a / 2;\na %= 3;  // Equivalente a: a = a % 3;"},{"nombre":"MessageDigest (hash)","main":"El hash identifica inequivocamente un mensaje con un texto ilegible de una longitud determinada que no permite revertirlo al mensaje original, dicho de otro modo: estamos cifrando un mensaje de forma que nunca podremos descifrar si no es empleando fuerza bruta.\n\nUna utilidad posible es almacenar el hash de una clave de usuario, cuando el usuario la introduce, se genera el hash de la clave escrita, y si coincide con la que el servidor tiene almacenada, el usuario sera validado. De este modo en caso de fuga de informacion las claves no quedan descubiertas de inmediato.","characters":"import java.security.MessageDigest;\n\n//CREA EL OBJETO\nMessageDigest md = MessageDigest.getInstance(\"SHA\");\n// INTRODUCE EL TEXTO\nmd.update(texto.getBytes());\n// CALCULA EH HASH\n// es una lista de bytes en 'crudo' no legible por el terminal\nbyte hash[] = md.digest();\n// PREPARA EL HASH PARA LECTURA HUMANA\nStringBuffer hexString = new StringBuffer();\nfor (int i = 0; i < hash.length; i++){\n    String hex = Integer.toHexString(0xff & hash[i]);\n    if (hex.length == 1) { hexString.append('0'); }\n    hexString.append(hex)\n}\nSystem.out.println(\"Hash: \" + hexString.toString());"},{"nombre":"- Firma digital","main":"La firma digital se usa para verificar que el mensaje no se ha modificado, ademas como el emisor requiere la clave privada, tambien sabemos quien ha firmado el mensaje identificando al emisor.\nSe requiere una autoridad certificadora que asegure que que la clave publica es de quien dice ser.\n\n1) A partir de un mensaje se genera un hash SHA1 que se cifra con la clave privada de tipo DSA, el archivo resultante es una firma SHA1withDSA\n2) El receptor con el mensaje y la clave publica verifica la firma: internamente se genera y compara el hash con el generado por el emisor que esta cifrado dentro de la firma, para obtener el hash generado por el emisor se desfra la firma con la clave publica del emisor.","characters":"import java.security.*;\n\npublic class T5S2P2VerificaSignaturaDigitalFONTS {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\n\t\t\t// GENERAR PAR DE CLAVES\n\t\t\t// crea objeto generador de claves con Digital Signature Algorithm (DSA)\n\t\t\tKeyPairGenerator KeyGen = KeyPairGenerator.getInstance(\"DSA\");\n\n\t\t\t// genera un numero aleatorio\n\t\t\tSecureRandom numero = SecureRandom.getInstance(\"SHA1PRNG\");\n\t\t\t// indicamos que queremos una clave de 1024 bits basada en el numero aleatorio\n\t\t\tKeyGen.initialize(1024, numero);\n\n\t\t\tKeyPair par = KeyGen.generateKeyPair();\n\n\t\t\t// GUARDA LAS CLAVES PUBLICA Y PRIVADA\n\t\t\tPrivateKey clavepriv = par.getPrivate(); // para cifrar\n\t\t\tPublicKey clavepub = par.getPublic(); // para descifrar\n\n\t\t\t// EMISSOR FIRMA CON CLAVE PRIVADA\n\t\t\t// crea objeto firma con hash SHA1 bajo DSA\n\t\t\tSignature dsa = Signature.getInstance(\"SHA1withDSA\");\n\t\t\t// agregamos la clave privada al objeto firma\n\t\t\tdsa.initSign(clavepriv);\n\t\t\t// pasamos el mensaje al objeto firma\n\t\t\tString mensaje = \"Este es el contenido del mensaje que debe ser firmado.\";\n\t\t\tdsa.update(mensaje.getBytes());\n\t\t\t// obtenemos la firma del mensaje\n\t\t\tbyte[] signatura = dsa.sign();\n\n\t\t\t// array de bytes a hexadecimal para lectura humana\n\t\t\tStringBuffer hexSignatura = new StringBuffer();\n\t\t\tfor (int i = 0; i < signatura.length; i++) {\n\t\t\t\tString hex = Integer.toHexString(0xff & signatura[i]);\n\t\t\t\tif (hex.length() == 1)\n\t\t\t\t\thexSignatura.append('0');\n\t\t\t\thexSignatura.append(hex);\n\t\t\t}\n\n\t\t\tSystem.out.println(\"*** El emisor firma el mensaje ***\");\n\t\t\tSystem.out.println(\"  Mensjaje firmado: \\n    \" + mensaje);\n\t\t\tSystem.out.println(\"  Firma: \\n    \" + hexSignatura);\n\t\t\tSystem.out.println();\n\n\n\n\n\n\n\n\n\n\n\t\t\t// RECEPCION DEL MENSAJE POR PARTE DEL CLIENTE\n\t\t\tSystem.out.println(\"*** El receptor recibe clave publica, mensaje, y la firma ***\");\n\t\t\tSystem.out.println(\"  Firma: \\n    \" + hexSignatura);\n\t\t\tSystem.out.println(\"  Mensaje: \\n    \" + mensaje);\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"\"\"\n\t\t\t\t\tEl receptor crea un nuevo objeto firma del mismo tipo que el emisor, le pasa la clave publica,\n\t\t\t\t\tel mensaje y por ultimo verifica la firma\n\t\t\t\t\t\"\"\");\n\t\t\t// receptor descifra la firma utilizando la clave publica del emisor\n\t\t\t// + el mensaje, obteniendo asi el hash que el emisor calculo, si el\n\t\t\t// hash coincide, la firma es valida\n\t\t\tSignature dsa2 = Signature.getInstance(\"SHA1withDSA\");\n\t\t\tdsa2.initVerify(clavepub);\n\t\t\tdsa2.update(mensaje.getBytes());\n\t\t\tboolean verifica = dsa2.verify(signatura);\n\n\t\t\tSystem.out.println(verifica ? \"  El hash calculado y el recibido son iguales: La firma es válida\"\n\t\t\t\t\t: \"  El hash calculado y el recibido son diferentes: La firma no es válida\");\n\t\t\tSystem.out.println();\n\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tSystem.out.println(\"NoSuchAlgorithmException en main(): \" + e);\n\t\t} catch (InvalidKeyException e) {\n\t\t\tSystem.out.println(\"InvalidKeyException en main(): \" + e);\n\t\t} catch (SignatureException e) {\n\t\t\tSystem.out.println(\"SignatureException en main(): \" + e);\n\t\t}\n\t}\n}"},{"nombre":"- Excepciones y errores","main":"Los errores y excepciones son conceptos clave en Java que se utilizan para gestionar situaciones inesperadas o erróneas durante la ejecución de un programa.\n\nERROR DE COMPILACION: Se deben a errores sintácticos, declarativos u otros problemas que impiden que el código fuente se compile.\nERROR EN TIEMPO DE EJECUCION: evento durante la ejecucion que genera una excepcion\nEXCEPCION: objeto que contiene la infomracion sobre las caracteristicas del error. Se manejan con TRY-CATCH-FINALLY\n\n","characters":""},{"nombre":"- Excepciones (propagacion)","main":"Cuando una excepción se propaga, significa que no se maneja dentro de la funcion donde ocurrió, sino que se pasa al origen de la llamada, y así sucesivamente, hasta que se encuentra un bloque catch que pueda manejar la excepción o hasta que alcanza el nivel superior del programa, en cuyo caso el programa terminará con un error.\n\nLa propagacion permite que los errores sean manejados en un nivel superior donde se tenga más contexto sobre cómo manejarlos, en lugar de manejarlos en el mismo nivel donde ocurrieron.","characters":"// LA EXCEPCION PASARA DEL METODO2() AL METODO1() Y AL MAIN DONDE SE GESTIONA\npublic class PropagacionExcepciones {\n    public static void main(String[] args) {\n        try {\n            metodo1();\n        } catch (Exception e) {\n            System.out.println(\"Excepción manejada en el método main: \" + e);\n        }\n    }\n\n    public static void metodo1() {\n        metodo2();\n    }\n\n    public static void metodo2() {\n        int resultado = 10 / 0; // Esto generará una excepción ArithmeticException\n    }\n}\n"},{"nombre":"- Encapsulado","main":"El encapsulado es el mecanismo que evita el acceso a lods datos de un objeto, normalmente variables, por cualquier otro metodo distinto a los especificados (funciones) y garantizando asi la integridad de los datos (variables) que contiene el objeto.\n","characters":"public class Vehiculo {\n    // PROPIEDADES PRIVATE PERMITEN EL ACCESO SOLO A TRAVES LOS METODOS (ENCAPSULAMIENTO)\n    private String marca;\n    private String modelo;\n    private int añoFabricacion;\n    private boolean enMarcha;\n\n    // CONSTRUCTOR\n    public Vehiculo(String marca, String modelo, int añoFabricacion) {\n        this.marca = marca;\n        this.modelo = modelo;\n        this.añoFabricacion = añoFabricacion;\n        this.enMarcha = false;  // Inicialmente, el vehículo no está en marcha\n    }\n\n    // METODO para encender el vehículo\n    // LOS METODOS SON PUBLIC PARA QUE SE PUEDAN LLAMAR DESDE FUERA DEL OBJETO\n    public void encender() {\n        if (!enMarcha) {\n            System.out.println(\"El vehículo está encendido.\");\n            enMarcha = true;\n        } else {\n            System.out.println(\"El vehículo ya está en marcha.\");\n        }\n    }\n\n    // METODO para apagar el vehículo\n    public void apagar() {\n        if (enMarcha) {\n            System.out.println(\"El vehículo está apagado.\");\n            enMarcha = false;\n        } else {\n            System.out.println(\"El vehículo ya está apagado.\");\n        }\n    }\n\n    // METODO para obtener información del vehículo\n    public void obtenerInformacion() {\n        System.out.println(\"Marca: \" + marca);\n        System.out.println(\"Modelo: \" + modelo);\n        System.out.println(\"Año de Fabricación: \" + añoFabricacion);\n        System.out.println(\"Estado: \" + (enMarcha ? \"En marcha\" : \"Apagado\"));\n    }\n\n    // PARTE EJECUTABLE DE NUESTRO CODIGO\n    public static void main(String[] args) {\n        // Crear una camioneta\n        Vehiculo camioneta = new Vehiculo(\"Toyota\", \"Hilux\", 2022);\n\n        // Crear un autobús\n        Vehiculo autobus = new Vehiculo(\"Mercedes-Benz\", \"Sprinter\", 2021);\n\n        // Operaciones con la camioneta\n        camioneta.encender();\n        camioneta.obtenerInformacion();\n        camioneta.apagar();\n\n        // Operaciones con el autobús\n        autobus.encender();\n        autobus.obtenerInformacion();\n        autobus.apagar();\n    }\n}\n"},{"nombre":"- Convenciones JAVA","main":"Para facilitar la lectura del codigo se emplean ciertas convenciones:\nNOMBRES:\nClases e interfaces: primera letra de cada palabra siempre en mayusculas\nMetodos y variables: primera letra en minuscula y primera de la segunda palabra en Mayusculas\nConstantes: todo en mayusculas y palabras separadas por guion bajo","characters":"NOMBRES\nClases: \n   class Cliente\n   class ImagenAnidada\n   interface Almacen\nMetodos y variables:\n   limpiaElArray()\n   calculaPosicion()\n   int numero = 3;\n   String textoCorto = \"hola mundo\";\nConstantes:\n   const ANCHURA_MAX = 2;\n   const YEAR = 1923;\n\n"},{"nombre":"- Constructor","main":"Un constructor en programación es un método especial de una clase que se llama automáticamente cuando se crea una instancia (objeto) de esa clase. Su principal función es inicializar los atributos y realizar cualquier configuración necesaria para el objeto recién creado.\n\nEn Java, un constructor tiene el mismo nombre que la clase a la que pertenece y no tiene un tipo de retorno explícito. \n\nLos constructores son esenciales en la programación orientada a objetos porque permiten asegurar que un objeto se inicialice correctamente antes de ser utilizado. Además, proporcionan una manera de establecer un estado inicial coherente para todas las instancias de una clase. En Java, si no se proporciona un constructor explícitamente, se crea un constructor predeterminado automáticamente, pero es común definir uno propio para controlar mejor la inicialización de los objetos.","characters":"public class Vehiculo {\n    // VARIABLES DEL NUEVO OBJETO QUE INICIALIZARA EL CONSTRUCTOR\n    private String marca;\n    private String modelo;\n    private int añoFabricacion;\n    private boolean enMarcha;\n\n    // CONSTRUCTOR RECIBE MARCA, MODELO Y AñO DE FABRICACION AL GENERAR UN NUEVO OBJETO\n    // NO REQUIERE QUE SE INDIQUE VOID AUNQUE NO EXISTA RETURN\n    public Vehiculo(String marca, String modelo, int añoFabricacion) {\n        this.marca = marca;\n        this.modelo = modelo;\n        this.añoFabricacion = añoFabricacion;\n        this.enMarcha = false;  // Inicialmente, el vehículo no está en marcha\n    }\n\n    // Metodo para encender el vehículo\n    public void encender() {\n        if (!enMarcha) {\n            System.out.println(\"El vehículo está encendido.\");\n            enMarcha = true;\n        } else {\n            System.out.println(\"El vehículo ya está en marcha.\");\n        }\n    }\n\n    // Metodo para apagar el vehículo\n    public void apagar() {\n        if (enMarcha) {\n            System.out.println(\"El vehículo está apagado.\");\n            enMarcha = false;\n        } else {\n            System.out.println(\"El vehículo ya está apagado.\");\n        }\n    }\n\n    // Metodo para obtener información del vehículo\n    public void obtenerInformacion() {\n        System.out.println(\"Marca: \" + marca);\n        System.out.println(\"Modelo: \" + modelo);\n        System.out.println(\"Año de Fabricación: \" + añoFabricacion);\n        System.out.println(\"Estado: \" + (enMarcha ? \"En marcha\" : \"Apagado\"));\n    }\n\n    // PARTE EJECUTABLE DE NUESTRO CODIGO\n    public static void main(String[] args) {\n        // CREAR UNA CAMIONETA LLAMA AL CONSTRUCTOR Y LE PASA CIERTOS PARAMETROS\n        Vehiculo camioneta = new Vehiculo(\"Toyota\", \"Hilux\", 2022);\n\n        // CREAR UN AUTOBUS LLAMA AL CONSTRUCTOR Y LE PASA OTROS PARAMETROS\n        Vehiculo autobus = new Vehiculo(\"Mercedes-Benz\", \"Sprinter\", 2021);\n\n        // Operaciones con la camioneta\n        camioneta.encender();\n        camioneta.obtenerInformacion();\n        camioneta.apagar();\n\n        // Operaciones con el autobús\n        autobus.encender();\n        autobus.obtenerInformacion();\n        autobus.apagar();\n    }\n}\n"},{"nombre":"- Clases, objetos y metodos","main":"Una CLASE es una abstraccion, el concepto, una especie de plantilla con la que generaremos un objeto.\nUn OBJETO es un elemento concreto de la clase, tambien llamado instancia. Se crean a traves de un constructor que tiene el mismo nombre que la clase y se encuentra dentro de ella.\nUn METODO o FUNCION es un comportamiento o funcionalidad de un objeto concreto\nUna PROPIEDAD o atributo es una caracteristica o especificacion y se suelen almacenar en variables de objeto.","characters":"public class Vehiculo {\n    // PROPIEDADES\n    private String marca;\n    private String modelo;\n    private int añoFabricacion;\n    private boolean enMarcha;\n\n    // CONSTRUCTOR\n    public Vehiculo(String marca, String modelo, int añoFabricacion) {\n        this.marca = marca;\n        this.modelo = modelo;\n        this.añoFabricacion = añoFabricacion;\n        this.enMarcha = false;  // Inicialmente, el vehículo no está en marcha\n    }\n\n    // METODO para encender el vehículo\n    public void encender() {\n        if (!enMarcha) {\n            System.out.println(\"El vehículo está encendido.\");\n            enMarcha = true;\n        } else {\n            System.out.println(\"El vehículo ya está en marcha.\");\n        }\n    }\n\n    // METODO para apagar el vehículo\n    public void apagar() {\n        if (enMarcha) {\n            System.out.println(\"El vehículo está apagado.\");\n            enMarcha = false;\n        } else {\n            System.out.println(\"El vehículo ya está apagado.\");\n        }\n    }\n\n    // METODO para obtener información del vehículo\n    public void obtenerInformacion() {\n        System.out.println(\"Marca: \" + marca);\n        System.out.println(\"Modelo: \" + modelo);\n        System.out.println(\"Año de Fabricación: \" + añoFabricacion);\n        System.out.println(\"Estado: \" + (enMarcha ? \"En marcha\" : \"Apagado\"));\n    }\n\n    // PARTE EJECUTABLE DE NUESTRO CODIGO\n    public static void main(String[] args) {\n        // Crear una camioneta\n        Vehiculo camioneta = new Vehiculo(\"Toyota\", \"Hilux\", 2022);\n\n        // Crear un autobús\n        Vehiculo autobus = new Vehiculo(\"Mercedes-Benz\", \"Sprinter\", 2021);\n\n        // Operaciones con la camioneta\n        camioneta.encender();\n        camioneta.obtenerInformacion();\n        camioneta.apagar();\n\n        // Operaciones con el autobús\n        autobus.encender();\n        autobus.obtenerInformacion();\n        autobus.apagar();\n    }\n}\n"},{"nombre":"- Bibliotecas Java estandard","main":"Las bibliotecas estándar de Java, también conocidas como Java Standard Library o Java API (Application Programming Interface), son un conjunto extenso de clases, interfaces y paquetes proporcionados por Java para facilitar el desarrollo de aplicaciones en este lenguaje. Estas bibliotecas abarcan una amplia variedad de áreas, desde operaciones básicas hasta funcionalidades avanzadas, y están organizadas en paquetes temáticos.\n\nJAVA.AWT Y JAVAX.SWING:\nProporcionan clases para construir interfaces gráficas de usuario (GUI). java.awt es la biblioteca original, mientras que javax.swing agrega componentes y funcionalidades más avanzadas.\n\nJAVA.IO:\nProporciona clases para realizar operaciones de entrada y salida (I/O), como lectura y escritura de archivos, flujo de bytes (InputStream, OutputStream), y flujos de caracteres (Reader, Writer).\n\nJAVA.LANG:\nContiene clases y objetos fundamentales que son automáticamente importados en todos los programas Java. Incluye clases como String, Object, System, Math, etc.\n\nJAVA.MATH:\nProporciona clases para operaciones matemáticas de precisión arbitraria, como BigInteger y BigDecimal.\n\nJAVA.NET:\nOfrece clases para realizar operaciones de red, como la creación de sockets, la gestión de URLs, la manipulación de conexiones HTTP, etc.\n\nJAVA.NIO:\nIntroduce clases para operaciones de E/S no bloqueantes, como Channel y Buffer, que son útiles para operaciones más eficientes en términos de rendimiento.\n\nJAVA.SECURITY:\nOfrece funcionalidades relacionadas con la seguridad, incluyendo el manejo de cifrado y descifrado, autenticación y autorización.\n\nJAVA.SQL:\nContiene clases y interfaces para la interacción con bases de datos a través del lenguaje SQL. Proporciona JDBC (Java Database Connectivity) para conectarse y ejecutar consultas en bases de datos.\n\nJAVA.UTIL:\nOfrece utilidades generales y estructuras de datos, como listas (ArrayList, LinkedList), conjuntos (HashSet, TreeSet), mapas (HashMap, TreeMap), clases para manipulación de fechas (Date, Calendar), y más.\n\nJAVA.UTIL.CONCURRENT:\nOfrece clases y interfaces para la programación concurrente, como Executor, ThreadPoolExecutor, y Future, facilitando el desarrollo de aplicaciones multihilo.","characters":""},{"nombre":"Try-catch-finally","main":"La estructura TRY-CATCH-FINALLY en Java es utilizada para manejar excepciones\n\nTRY: Contiene el bloque de código donde se espera que ocurran excepciones.\nCATCH: Contiene el código que se ejecutará si ocurre una excepción en try, es posible tener varios bloques catch para manejar diferentes tipos de excepciones. Catch se ejecuta solo si se produce una excepción del tipo especificado.\nFINALLY: Es opcional y contiene el código que se ejecutará siempre, y se utiliza para realizar operaciones de limpieza, liberación de recursos, o cualquier tarea que deba hacerse sin importar si hubo una excepción o no.","characters":"public class EjemploTryCatchFinally {\n    public static void main(String[] args) {\n        try {\n            int resultado = 10/0; // DIVISION POR CERO!\n            System.out.println(\"Resultado: \" + resultado);\n        } catch (ArithmeticException e) {\n            System.err.println(\"ArithmeticException: División por cero.\");\n        } catch (Exception e) {\n            System.err.println(\"Exception: \" + e); // Muestra cualquier otra excepcion\n        } finally {\n            System.out.println(\"Este bloque siempre se ejecuta.\");\n        }\n    }\n}\n"},{"nombre":"array bidimensional (tipo complejo)","main":"Un array bidimensional en Java es una estructura de datos que almacena elementos en filas y columnas, formando así una especie de cuadrícula. También se le conoce como matriz bidimensional y proporcionan una forma eficiente de organizar datos en una cuadrícula, facilitando el acceso y manipulación de elementos. Las matrices bidimensionales son comúnmente utilizadas para representar tablas, gráficos bidimensionales, juegos de tablero, imágenes, y otros casos donde la información tiene una estructura de cuadrícula.\n\nACCESO A SUS ELEMENTOS: se accede mediante índices de fila y columna. Por ejemplo, matrizEnteros[1][2] accede al elemento en la segunda fila y tercera columna.\nLONGITUD DE FILAS Y COLUMNAS:las filas se obtienen con matriz.length, y la longitud de las columnas se obtiene con matriz[0].length. Es importante notar que se asume que todas las filas tienen la misma longitud.\nRECORRER EL ARRAY: se utilizan dos bucles anidados (uno para las filas y otro para las columnas).","characters":"public class RecorridoArrayBidimensional {\n    public static void main(String[] args) {\n        // Declaración e inicialización del array bidimensional \n        int[][] arrayBidimensional = {\n                {1, 2, 3},\n                {4, 5, 6},\n                {7, 8, 9},\n                {10, 11, 12}\n        };\n        // Declaracion de un array bidimensional vacio\n        int[][] arrayBi2 = new int[4][3];\n\n        // Obtener la cantidad de filas y columnas\n        int filas = arrayBidimensional.length;\n        int columnas = arrayBidimensional[0].length; // Se asume que todas las filas tienen la misma longitud\n\n        // Recorrido de la matriz bidimensional utilizando bucles for\n        for (int i = 0; i < filas; i++) {\n            for (int j = 0; j < columnas; j++) {\n                System.out.print(arrayBidimensional[i][j]);\n            }\n            // Salto de línea al final de cada fila para mejorar la presentación\n            System.out.println();\n        }\n    }\n}\n"},{"nombre":"string (tipo complejo)","main":"En Java, String es una clase que representa una secuencia inmutable de caracteres. \n\nMETODOS DE STRING: métodos comunes son length(), charAt(), concat(), substring(), equals(), compareTo(), toUpperCase(), toLowerCase(), toCharArray() o String.valueOf().\nCONCATENADO DE STRINGS: La concatenación de cadenas en Java se puede realizar utilizando el operador + o mediante el método concat().\nCOMPARACION DE CADENAS: Para comparar cadenas se utilizan métodos como equals(), equalsIgnoreCase(), compareTo() (mayor/menor alfabeticamente), o compareToIgnoreCase(). \nNUNCA COMPARAREMOS CADENAS CON ==","characters":"String mensaje = \"Hola, mundo!\";\nSystem.out.println(mensaje);\n"},{"nombre":"array (tipo complejo)","main":"Un array es una estructura de datos que almacena elementos del mismo tipo en una secuencia contigua de memoria. Es una forma eficiente de almacenar y acceder a múltiples valores bajo un mismo nombre. Cada elemento en un array se identifica mediante un índice o posición, y los índices suelen comenzar desde 0.\n\nCaracterísticas clave de los arrays:\n1) Tipo de Elementos Homogéneo: Todos los elementos de un array deben ser del mismo tipo de datos, ya sea primitivo (como int, char, float) o un objeto.\n2) Tamaño Fijo o Dinámico: Un array se define al momento de su creación y no se puede cambiar el numero de elementos que contiene.\n3) Índices Numéricos: Los elementos de un array se acceden mediante índices numéricos. El primer elemento suele tener el índice 0, el segundo el índice 1, y así sucesivamente.","characters":"// DOS MANERAS DE CREAR UN ARRAY\nint[] miArray = new int[12];\nint[] miArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n\n// AGREGAR VALORES A UN ARRAY\nnumeros[0] = 10;\nnumeros[1] = 20;\n\n// BUCLE FOR PARA RECORRER UN ARRAY\nfor (int i = 0; i < numeros.length; i++) {\n    System.out.println(numeros[i]);\n}\n\n// BUCLE FOREACH PARA RECORRER UN ARRAY\n// no permite cambios en el contenido del array\nfor (int numero : numeros) {\n    System.out.println(numero);\n}"},{"nombre":"This","main":"THIS en Java es una referencia al objeto en el que nos encontramos.\n\nSi tras THIS ponemos un punto, tendremos acceso a los metodos y variables del objeto actual","characters":"// CREAMOS UN OBJETO CajaCerillas INDICANDO AL CONSTRUCTOR CUANTAS CERILLAS COTIENE\npublic class CajaCerillas {\n    private int cantidad;\n\n    public CajaCerillas(int cantidad) {\n        //Evitamos la colision de nombres de variable y parametro recibido usando this\n        this.cantidad = cantidad; \n    }\n}\n\nCODIGO EQUIVALENTE:\n\npublic class CajaCerillas {\n    private int cantidad;\n\n    public CajaCerillas(int total) {\n        cantidad = total;\n    }\n}\n"},{"nombre":"For-each (bucle)","main":"El bucle \"for-each\" (también conocido como bucle \"enhanced for\" o bucle \"foreach\") en Java se utiliza para iterar a través de elementos de una colección (como un array o una lista) sin la necesidad de utilizar un índice explícito. Su sintaxis es más simple y fácil de leer en comparación con el bucle for tradicional. \n\nEs importante destacar que el bucle for-each se puede utilizar con cualquier tipo de colección iterable, como listas, conjuntos o mapas entre otros. Además, el bucle for-each no permite la modificación de la colección mientras se está iterando","characters":"public class EjemploForEach {\n    public static void main(String[] args) {\n        int[] numeros = {1, 2, 3, 4, 5};\n\n        // Iterar a través de los elementos del array\n        for (int numero : numeros) {\n            System.out.println(\"Número: \" + numero);\n        }\n    }\n}\n"},{"nombre":"For (bucle)","main":"El bucle for en Java es una estructura de control de flujo que permite ejecutar un bloque de código repetidamente, con mayor conveniencia para inicializar, probar y actualizar una variable de control\n\nEl bucle for es especialmente útil cuando conoces de antemano el número de iteraciones que deseas realizar. Puedes ajustar la inicialización, condición y actualización según tus necesidades específicas.","characters":"public class EjemploFor {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 5; i++) {\n            System.out.println(\"Número: \" + i);\n        }\n    }\n}\n"},{"nombre":"Do-while (bucle)","main":"El bucle do-while en Java es similar al bucle while, pero con una diferencia fundamental: el bloque de código dentro del do-while se ejecuta al menos una vez, incluso si la condición es inicialmente falsa. \n\nEl bucle do-while es útil cuando deseas garantizar que el bloque de código se ejecute al menos una vez, independientemente de la condición inicial. Sin embargo, como con cualquier bucle, es crucial asegurarse de que la condición eventualmente se vuelva falsa para evitar bucles infinitos.","characters":"public class EjemploDoWhile {\n    public static void main(String[] args) {\n        int contador = 1;\n\n        do {\n            System.out.println(\"Número: \" + contador);\n            contador++;\n        } while (contador <= 5);\n    }\n}\n"},{"nombre":"Swich-case (Estructura de decision)","main":"La declaración switch... case se utiliza para realizar selecciones múltiples basadas en el valor de una expresión. Es una alternativa más limpia y eficiente que una serie de declaraciones if-else anidadas cuando se desea comparar un valor con múltiples casos. \n\nEs importante incluir un break o se ejecutaran todos los casos posteriores al seleccionado.\nswitch case solo funciona con Boolean, int o char","characters":"switch (expresion) {\n    case valor1:\n        // Código a ejecutar si la expresión es igual a valor1\n        break;\n    case valor2:\n        // Código a ejecutar si la expresión es igual a valor2\n        break;\n    // Más casos...\n    default:\n        // Código a ejecutar si la expresión no coincide con ningún caso\n}\n"},{"nombre":"short (tipo primitivo)","main":"Un tipo primitivo (o tipo de dato primitivo) se refiere a un tipo de dato básico que no está compuesto por otras estructuras de datos. Estos tipos de datos primitivos son los elementos fundamentales con los que se construyen los programas y se utilizan para representar valores simples\n\nshort es un tipo de dato primitivo que se utiliza para representar números enteros más grandes que byte pero más pequeños que int, ocupa 16 bits o 2 bytes en la memoria y puede almacenar un rango desde -32,768 hasta 32,767. Es apropiado cuando necesitas representar números enteros más grandes que byte pero aún así deseas conservar memoria en comparación con un int.","characters":"short a = 2000;\nshort b = 3000;\nshort suma = (short) (a + b);      // suma = 5000\nshort resta = (short) (a - b);     // resta = -1000\nshort multiplicacion = (short) (a * b);  // multiplicacion = -27648 (se produce un desbordamiento)\nshort division = (short) (b / a);  // division = 1\n"},{"nombre":"byte (tipo primitivo)","main":"Un tipo primitivo (o tipo de dato primitivo) se refiere a un tipo de dato básico que no está compuesto por otras estructuras de datos. Estos tipos de datos primitivos son los elementos fundamentales con los que se construyen los programas y se utilizan para representar valores simples\n\nbyte es un tipo de dato primitivo que se utiliza para representar números enteros pequeños y ocupa 8 bits o 1 byte en la memoria, se utiliza comúnmente en situaciones donde se necesita conservar memoria y el rango de valores es suficiente para la aplicación. El rango de valores que puede almacenar un byte va desde -128 hasta 127.","characters":"byte a = 10;\nbyte b = 20;\nbyte suma = (byte) (a + b);      // suma = 30\nbyte resta = (byte) (a - b);     // resta = -10\nbyte multiplicacion = (byte) (a * b);  // multiplicacion = 200\nbyte division = (byte) (b / a);  // division = 2"},{"nombre":"Random","main":"En Java, Random es una clase que pertenece al paquete java.util y proporciona métodos para generar números aleatorios. Está diseñada para generar secuencias de números aparentemente aleatorios mediante algoritmos específicos.\n\nLa clase Random utiliza un generador de números pseudoaleatorios, este produce secuencias de números que se comportan como si fueran aleatorios, pero en realidad son deterministas y se generan a partir de un valor inicial llamado \"semilla\".","characters":"import java.util.Random;\n\nRandom random = new Random();\nint numeroAlAzar = random.nextInt(6) + 1;"},{"nombre":"DataInputStream & DataOutputStream","main":"DataInputStream y DataOutputStream son clases en Java que proporcionan facilidades para la lectura y escritura de datos primitivos y otros tipos de datos en formato binario y están diseñadas para trabajar con datos en formato binario. En el ejemplo los utilizaremos para enviar informacion a traves de un socket entre cliente y servidor.\n\nDataInputStream: Esta clase permite la lectura de datos primitivos y otros tipos de datos desde un flujo de entrada. Ofrece métodos como readInt(), readDouble(), readBoolean(), etc., que te permiten leer datos en el mismo formato que fueron escritos utilizando un DataOutputStream.","characters":"import java.net.*;\nimport java.io.*;\n\n//FLUJO DE ENTRADA\nDataInputStream flujoEntrada = new DataInputStream(socket.getInputStream());\nint numero = flujoEntrada.readInt();\nString texto = flujoEntrada.readUTF();\nbyte[] byteArray = flujoEntrada.read();\n\n//FLUJO DE SALIDA\nDataOutputStream flujoSalida = new DataOutputStream(socket.getOutputStream());\nflujoSalida.writeInt(numero);\nflujoSalida.writeUTF(texto);\nflujoSalida.write(byteArray);"}]